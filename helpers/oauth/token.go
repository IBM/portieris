// Copyright 2018 IBM
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package oauth

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"regexp"
	"strings"
	"time"
)

// TokenResponse is a generic OAuth2 token response
type TokenResponse struct {
	Token        Token     `json:"token,omitempty"`
	AccessToken  Token     `json:"access_token,omitempty"`
	RefreshToken string    `json:"refresh_token,omitempty"`
	ExpiresIn    int       `json:"expires_in,omitempty"`
	IssuedAt     time.Time `json:"issued_at,omitempty"`
}

// UnmarshalJSON unmarshals a byte slice into a BearerRequest
func (t *TokenResponse) UnmarshalJSON(b []byte) error {
	type Alias TokenResponse
	tmp := struct {
		Token       string `json:"token,omitempty"`
		AccessToken string `json:"access_token,omitempty"`
		*Alias
	}{Alias: (*Alias)(t)}
	if err := json.Unmarshal(b, &tmp); err != nil {
		return err
	}
	token, _ := ParseToken(tmp.Token)
	accessToken, _ := ParseToken(tmp.AccessToken)
	tmp.Alias.Token = token
	tmp.Alias.AccessToken = accessToken
	t = (*TokenResponse)(tmp.Alias)
	return nil
}

// Token describes a JWT bearer/access token
type Token interface {
	IssuedAt() (time.Time, error)
	Subject() (string, error)
}

// RegistryOAuthToken describes the short-lived bearer tokens we provide to users, defined here: https://docs.docker.com/registry/spec/auth/jwt/#getting-a-bearer-token
type RegistryOAuthToken string

// IssuedAt returns the time.Time this token was issued
func (t RegistryOAuthToken) IssuedAt() (time.Time, error) {
	return timeFromClaims(string(t), "iat")
}

// Subject returns the subject of the token (e.g. ibmID)
func (t RegistryOAuthToken) Subject() (string, error) {
	return stringFromClaims(string(t), "sub")
}

// IAMToken describes access tokens generated by the IBM IAM service.
type IAMToken string

// IssuedAt returns the time.Time this token was issued
func (t IAMToken) IssuedAt() (time.Time, error) {
	return timeFromClaims(string(t), "iat")
}

// Subject returns the unique ibmID of the user that the token was generated for.
func (t IAMToken) Subject() (string, error) {
	return stringFromClaims(string(t), "id")
}

// UAAToken describes access tokens generated by the Bluemix UAA service.
type UAAToken string

// IssuedAt returns the time.Time this token was issued
func (t UAAToken) IssuedAt() (time.Time, error) {
	return timeFromClaims(string(t), "iat")
}

// Subject returns the unique CloudFoundry user ID of the user that the token was generated for.
func (t UAAToken) Subject() (string, error) {
	return stringFromClaims(string(t), "user_id")

}

var (
	iamRegex      = regexp.MustCompile(`^https://iam(?:\.[^.]+){0,2}\.bluemix\.net`)
	uaaRegex      = regexp.MustCompile(`^https://uaa(?:\.stage1)?\.[^.]+\.bluemix\.net/oauth/token$`)
	registryRegex = regexp.MustCompile(`^registry((-dev|-prestage)?\.stage1)?(\.[^.]+)?\.bluemix\.net$`)
)

// UnknownToken is a token we do not know and couldn't parse. This is the result of a failed ParseToken.
// The main reason this exists is; if during an UnmarshalJSON the call to ParseToken fails,
// we don't want to lose the string in case we need to perform some action on it or pass it through to a user.
// i.e. we return an UnknownToken wrapping the string that satisfies the Token interface.
type UnknownToken string

// IssuedAt errors as we don't know how to parse the token
func (t UnknownToken) IssuedAt() (time.Time, error) {
	return time.Time{}, fmt.Errorf("cannot get IssuedAt for unknown token")
}

// Subject errors as we don't know how to parse the token
func (t UnknownToken) Subject() (string, error) {
	return "", fmt.Errorf("cannot get Subject for unknown token")

}

// ParseToken attempts to parse the provided token into a known token type using the issuer. If it is invalid or has an unknown
// issuer, an UnknownToken will be returned.
func ParseToken(token string) (Token, error) {
	issuer, err := stringFromClaims(token, "iss")
	if err != nil {
		return UnknownToken(token), fmt.Errorf("unable to parse token: %v", err)
	}
	if iamRegex.MatchString(issuer) {
		return IAMToken(token), nil
	}
	if uaaRegex.MatchString(issuer) {
		return UAAToken(token), nil
	}
	if registryRegex.MatchString(issuer) {
		return RegistryOAuthToken(token), nil
	}
	return UnknownToken(token), &ErrorUnknownIssuer{Issuer: issuer}
}

func timeFromClaims(token, field string) (time.Time, error) {
	epochT, err := intFromClaims(token, field)
	if err != nil {
		return time.Time{}, err
	}
	return time.Unix(epochT, 0), nil
}

func intFromClaims(token, field string) (int64, error) {
	claims, err := getClaims(token)
	if err != nil {
		return 0, err
	}
	if _, ok := claims[field]; !ok {
		return 0, fmt.Errorf("%q missing from claims", field)
	}
	res, ok := claims[field].(int64)
	if !ok {
		return 0, fmt.Errorf("%q not of type int64 in claims", field)
	}
	return res, nil
}

func stringFromClaims(token, field string) (string, error) {
	claims, err := getClaims(token)
	if err != nil {
		return "", err
	}
	if _, ok := claims[field]; !ok {
		return "", fmt.Errorf("%q missing from claims", field)
	}
	res, ok := claims[field].(string)
	if !ok {
		return "", fmt.Errorf("%q not of type string in claims", field)
	}
	return res, nil
}

func getClaims(token string) (map[string]interface{}, error) {
	parts := strings.Split(token, ".")
	if len(parts) != 3 {
		return nil, fmt.Errorf("unexpected amount of access parts: %v", len(parts))
	}
	claimMap := map[string]interface{}{}
	claims, err := base64.RawURLEncoding.DecodeString(parts[1])
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding IAM access claims: %v", err)
	}
	err = json.Unmarshal(claims, &claimMap)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling IAM access claims: %v", err)
	}
	return claimMap, nil
}

// ErrorUnknownIssuer is returned when a tokens issuer is not known
type ErrorUnknownIssuer struct {
	Issuer string
}

// Error returns the string friendly error
func (e *ErrorUnknownIssuer) Error() string {
	return fmt.Sprintf("Unknown issuer: %v", e.Issuer)
}
