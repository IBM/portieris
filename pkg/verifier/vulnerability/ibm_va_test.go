// Copyright 2020 Portieris Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package vulnerability

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"net/http"
	"sync"
	"testing"
	"time"

	"github.com/IBM/portieris/helpers/credential"
	"github.com/IBM/portieris/helpers/image"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

type MockHTTP struct {
	mock.Mock
}

func (m *MockHTTP) Do(req *http.Request) (*http.Response, error) {
	args := m.Called(req)
	return args.Get(0).(*http.Response), args.Error(1)
}

func userPasswordToBasicAuth(user, password string) string {
	auth := user + ":" + password
	return "Basic " + base64.StdEncoding.EncodeToString([]byte(auth))
}

type doMock struct {
	inAuthorization string
	outBody         string
	outStatusCode   int
	outErr          error
}

var cred1 = credential.Credential{Username: "user", Password: "pass"}
var singleCreds = credential.Credentials{cred1}
var tripleCreds = credential.Credentials{
	cred1,
	{Username: "user1", Password: "pass1"},
	{Username: "user2", Password: "pass2"},
}

func Test_NewIBMVulnerabilityAdvisorScanner(t *testing.T) {
	c := NewIBMVulnerabilityAdvisorScanner(singleCreds, "123")
	assert.Equal(t, "123", c.AccountHeader)
}

func Test_CanImageDeployBasedOnVulnerabilities(t *testing.T) {
	nonIBMRepo := "mythical.registry/repo:tag"
	ibmRepo := "icr.io/sam/ida:may"
	sleepTime = time.Microsecond
	tests := []struct {
		name           string
		fullImageName  string
		doMock         *doMock
		expectedResult ScanResponse
		expectedError  error
	}{
		{
			name:          "It should error if not an IBM repo",
			fullImageName: nonIBMRepo,
			expectedError: fmt.Errorf("Cannot use Vulnerability Advisor for IBM Cloud Container Registry with image %q", nonIBMRepo),
		},
		{
			name:          "It should set CanDeploy `true` when VA returns OK",
			fullImageName: ibmRepo,
			doMock: &doMock{
				inAuthorization: userPasswordToBasicAuth("user", "pass"),
				outBody:         `{"status": "OK"}`,
				outStatusCode:   http.StatusOK,
			},
			expectedResult: ScanResponse{CanDeploy: true},
		},
		{
			name:          "It should set CanDeploy `true` when VA returns WARN",
			fullImageName: ibmRepo,
			doMock: &doMock{
				inAuthorization: userPasswordToBasicAuth("user", "pass"),
				outBody:         `{"status": "WARN"}`,
				outStatusCode:   http.StatusOK,
			},
			expectedResult: ScanResponse{CanDeploy: true},
		},
		{
			name:          "It should set CanDeploy `true` when VA returns UNSUPPORTED",
			fullImageName: ibmRepo,
			doMock: &doMock{
				inAuthorization: userPasswordToBasicAuth("user", "pass"),
				outBody:         `{"status": "UNSUPPORTED"}`,
				outStatusCode:   http.StatusOK,
			},
			expectedResult: ScanResponse{CanDeploy: true},
		},
		{
			name:          "It should set CanDeploy `false` and set DenyReason when VA returns any other status",
			fullImageName: ibmRepo,
			doMock: &doMock{
				inAuthorization: userPasswordToBasicAuth("user", "pass"),
				outBody:         `{"status": "BLOCK"}`,
				outStatusCode:   http.StatusOK,
			},
			expectedResult: ScanResponse{CanDeploy: false, DenyReason: "Image icr.io/sam/ida:may CANNOT DEPLOY with Vulnerability Advisor for IBM Cloud Container Registry status \"BLOCK\""},
		},
		{
			name:          "It should set CanDeploy `false` and set DenyReason if VA returns an error",
			fullImageName: ibmRepo,
			doMock: &doMock{
				inAuthorization: userPasswordToBasicAuth("user", "pass"),
				outBody:         `{}`,
				outStatusCode:   http.StatusForbidden,
			},
			expectedResult: ScanResponse{CanDeploy: false, DenyReason: "Image icr.io/sam/ida:may CANNOT DEPLOY due to Vulnerability Advisor for IBM Cloud Container Registry error: \"Not authorised to get Vulnerability Advisor for IBM Cloud Container Registry scan result for \\\"icr.io/sam/ida:may\\\": unauthorised\""},
			expectedError:  fmt.Errorf("Not authorised to get Vulnerability Advisor for IBM Cloud Container Registry scan result for %q: %w", ibmRepo, ErrorUnauthorised),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockHTTP := MockHTTP{}

			if tt.doMock != nil {
				defer mockHTTP.AssertExpectations(t)
				mockHTTP.Test(t)

				request, err := http.NewRequest("GET", "https://icr.io/va/api/v3/report/image/status/"+tt.fullImageName, nil)
				require.NoError(t, err)
				request.Header.Add("Authorization", tt.doMock.inAuthorization)

				response := http.Response{
					StatusCode: tt.doMock.outStatusCode,
					Body:       ioutil.NopCloser(bytes.NewBuffer([]byte(tt.doMock.outBody))),
				}
				mockHTTP.On("Do", request).Return(&response, tt.doMock.outErr).Once()
			}

			client := IBMVAScanner{
				credentials: credential.Credentials{
					{
						Username: "user",
						Password: "pass",
					},
				},
				client: &mockHTTP,
			}

			image, err := image.NewReference(tt.fullImageName)
			require.NoError(t, err)

			result, err := client.CanImageDeployBasedOnVulnerabilities(*image)

			assert.Equal(t, tt.expectedResult, result)
			assert.Equal(t, tt.expectedError, err)
		})
	}

}

func Test_getImageStatus(t *testing.T) {
	sleepTime = time.Microsecond
	tests := []struct {
		name           string
		credentials    credential.Credentials
		accountHeader  string
		fullImageName  string
		doMocks        []doMock
		expectedResult IBMVASummary
		expectedError  error
	}{
		{
			name:          "It should call the VA API and return a result when image is tagged",
			credentials:   singleCreds,
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user", "pass"),
					outBody:         `{"status": "OK"}`,
					outStatusCode:   http.StatusOK,
				},
			},
			expectedResult: IBMVASummary{Status: "OK"},
		},
		{
			name:          "It should call the VA API and return a result when image is by digest",
			credentials:   singleCreds,
			fullImageName: "icr.io/sam/ida@sha256:abc",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user", "pass"),
					outBody:         `{"status": "OK"}`,
					outStatusCode:   http.StatusOK,
				},
			},
			expectedResult: IBMVASummary{Status: "OK"},
		},
		{
			name:          "It should include the Account header when calling VA if set",
			credentials:   singleCreds,
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user", "pass"),
					outBody:         `{"status": "OK"}`,
					outStatusCode:   http.StatusOK,
				},
			},
			accountHeader:  "anaccount",
			expectedResult: IBMVASummary{Status: "OK"},
		},
		{
			name:          "It should try different credentials if the VA API returns 401 or 403",
			credentials:   tripleCreds,
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user", "pass"),
					outStatusCode:   http.StatusUnauthorized,
					outBody:         ``,
				},
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   http.StatusForbidden,
					outBody:         ``,
				},
				{
					inAuthorization: userPasswordToBasicAuth("user2", "pass2"),
					outStatusCode:   http.StatusOK,
					outBody:         `{"status": "OK"}`,
				},
			},
			expectedResult: IBMVASummary{Status: "OK"},
		},
		{
			name:          "All creds return unauthorised",
			credentials:   tripleCreds,
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user", "pass"),
					outStatusCode:   http.StatusUnauthorized,
					outBody:         ``,
				},
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   http.StatusUnauthorized,
					outBody:         ``,
				},
				{
					inAuthorization: userPasswordToBasicAuth("user2", "pass2"),
					outStatusCode:   http.StatusUnauthorized,
					outBody:         ``,
				},
			},
			expectedError: fmt.Errorf("Not authorised to get Vulnerability Advisor for IBM Cloud Container Registry scan result for \"icr.io/sam/ida:latest\": %w", ErrorUnauthorised),
		},
		{
			name: "try again 3 times for an internal server error",
			credentials: credential.Credentials{
				{Username: "user1", Password: "pass1"},
			},
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   http.StatusServiceUnavailable,
					outBody:         ``,
				},
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   http.StatusInternalServerError,
					outBody:         ``,
				},
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   http.StatusBadGateway,
					outBody:         ``,
				},
			},
			expectedError: fmt.Errorf("Failed to get Vulnerability Advisor for IBM Cloud Container Registry scan result for \"icr.io/sam/ida:latest\": %v", "Internal server error"),
		},
		{
			name: "Retry three times and then error for unexpected 5** responses",
			credentials: credential.Credentials{
				{Username: "user1", Password: "pass1"},
			},
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   599,
					outBody:         ``,
				},
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   599,
					outBody:         ``,
				},
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   599,
					outBody:         ``,
				},
			},
			expectedError: fmt.Errorf("Failed to get Vulnerability Advisor for IBM Cloud Container Registry scan result for \"icr.io/sam/ida:latest\": Unhandled response from Vulnerability Advisor for IBM Cloud Container Registry: 599"),
		},
		{
			name: "Retry three times and then error for client.Do failing",
			credentials: credential.Credentials{
				{Username: "user1", Password: "pass1"},
			},
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   550,
					outBody:         ``,
					outErr:          fmt.Errorf("uh oh"),
				},
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   550,
					outBody:         ``,
					outErr:          fmt.Errorf("uh oh"),
				},
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   550,
					outBody:         ``,
					outErr:          fmt.Errorf("uh oh"),
				},
			},
			expectedError: fmt.Errorf("Failed to get Vulnerability Advisor for IBM Cloud Container Registry scan result for \"icr.io/sam/ida:latest\": uh oh"),
		},
		{
			name: "Return decoding error if VA response is not valid JSON",
			credentials: credential.Credentials{
				{Username: "user1", Password: "pass1"},
			},
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   http.StatusOK,
					outBody:         `{"issue_count": "nan"}`,
				},
			},
			expectedError: fmt.Errorf("Failed to get Vulnerability Advisor for IBM Cloud Container Registry scan result for \"icr.io/sam/ida:latest\": json: cannot unmarshal string into Go struct field IBMVASummary.issue_count of type int"),
		},
		{
			name: "If image isn't found, return error and don't call VA again",
			credentials: credential.Credentials{
				{Username: "user1", Password: "pass1"},
				{Username: "user2", Password: "pass2"},
				{Username: "user3", Password: "pass3"},
			},
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   404,
					outBody:         ``,
				},
			},
			expectedError: fmt.Errorf("Failed to get Vulnerability Advisor for IBM Cloud Container Registry scan result for \"icr.io/sam/ida:latest\": %v", "Not found"),
		},
		{
			name: "If bad request response, return error and don't try again",
			credentials: credential.Credentials{
				{Username: "user1", Password: "pass1"},
				{Username: "user2", Password: "pass2"},
				{Username: "user3", Password: "pass3"},
			},
			fullImageName: "icr.io/sam/ida:latest",
			doMocks: []doMock{
				{
					inAuthorization: userPasswordToBasicAuth("user1", "pass1"),
					outStatusCode:   400,
					outBody:         ``,
				},
			},
			expectedError: fmt.Errorf("Failed to get Vulnerability Advisor for IBM Cloud Container Registry scan result for \"icr.io/sam/ida:latest\": %v", "Bad request"),
		},
		{
			name:          "If there are no credentials on the client, error",
			credentials:   credential.Credentials{},
			fullImageName: "icr.io/sam/ida:latest",
			expectedError: fmt.Errorf("No credentials on client to call Vulnerability Advisor for IBM Cloud Container Registry with"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockHTTP := MockHTTP{}
			defer mockHTTP.AssertExpectations(t)
			mockHTTP.Test(t)

			for _, mockDo := range tt.doMocks {
				request, err := http.NewRequest("GET", "https://icr.io/va/api/v3/report/image/status/"+tt.fullImageName, nil)
				require.NoError(t, err)
				request.Header.Add("Authorization", mockDo.inAuthorization)
				if tt.accountHeader != "" {
					request.Header.Add("Account", tt.accountHeader)
				}

				response := http.Response{
					StatusCode: mockDo.outStatusCode,
					Body:       ioutil.NopCloser(bytes.NewBuffer([]byte(mockDo.outBody))),
				}
				mockHTTP.On("Do", request).Return(&response, mockDo.outErr).Once()
			}

			client := IBMVAScanner{
				credentials:   tt.credentials,
				client:        &mockHTTP,
				AccountHeader: tt.accountHeader,
			}

			image, err := image.NewReference(tt.fullImageName)
			require.NoError(t, err)

			result, err := client.getImageStatus(*image)

			assert.Equal(t, tt.expectedResult, result)
			assert.Equal(t, tt.expectedError, err)
		})
	}
}

type mockAuthenticatorFactory struct {
	mock.Mock
}

func (maf *mockAuthenticatorFactory) NewAuthenticator(apiKey string) (requestAuthenticator, error) {
	args := maf.Called(apiKey)
	var authenticator requestAuthenticator
	if a, ok := args.Get(0).(requestAuthenticator); ok {
		authenticator = a
	}
	return authenticator, args.Error(1)
}

type mockRequestAuthenticator struct {
	mock.Mock
	authorizationHeader string
}

func (mra *mockRequestAuthenticator) Authenticate(request *http.Request) error {
	args := mra.Called(request)
	request.Header.Add("Authorization", mra.authorizationHeader)
	return args.Error(0)
}

func TestIBMVAScanner_getAuthenticator(t *testing.T) {
	type testCase struct {
		cred                  credential.Credential
		callNewAuthenticator  bool
		newAuthenticator      requestAuthenticator
		newAuthenticatorError error
		expectedError         error
	}
	tests := []struct {
		name                string
		initialItemsInCache map[string]interface{}
		cases               []testCase
		expectedCacheLen    int
		expectedKeyMatches  int
	}{
		{
			name: "Adds authenticator to the cache",
			cases: []testCase{
				{
					cred:                 credential.Credential{Password: "password123"},
					newAuthenticator:     &mockRequestAuthenticator{authorizationHeader: "password123"},
					callNewAuthenticator: true,
				},
			},
			expectedCacheLen:   1,
			expectedKeyMatches: 1,
		},
		{
			name: "It returns errors",
			cases: []testCase{
				{
					cred:                  credential.Credential{Password: "supersecure"},
					newAuthenticator:      nil,
					callNewAuthenticator:  true,
					newAuthenticatorError: fmt.Errorf("Couldn't cast authenticator"),
					expectedError:         fmt.Errorf("Couldn't cast authenticator"),
				},
			},
			expectedCacheLen:   0,
			expectedKeyMatches: 0,
		},
		{
			name: "Returns cached authenticator if found",
			cases: []testCase{
				{
					cred:                 credential.Credential{Password: "password123"},
					newAuthenticator:     &mockRequestAuthenticator{authorizationHeader: "password123"},
					callNewAuthenticator: true,
				},
				{
					cred:             credential.Credential{Password: "password123"},
					newAuthenticator: &mockRequestAuthenticator{authorizationHeader: "password123"},
				},
			},
			expectedCacheLen:   1,
			expectedKeyMatches: 2,
		},
		{
			name: "Handles multiple authenticators",
			cases: []testCase{
				{
					cred:                 credential.Credential{Password: "password123"},
					newAuthenticator:     &mockRequestAuthenticator{authorizationHeader: "password123"},
					callNewAuthenticator: true,
				},
				{
					cred:                 credential.Credential{Password: "password456"},
					newAuthenticator:     &mockRequestAuthenticator{authorizationHeader: "password456"},
					callNewAuthenticator: true,
				},
				{
					cred:                 credential.Credential{Password: "password789"},
					newAuthenticator:     &mockRequestAuthenticator{authorizationHeader: "password789"},
					callNewAuthenticator: true,
				},
				{
					cred:             credential.Credential{Password: "password789"},
					newAuthenticator: &mockRequestAuthenticator{authorizationHeader: "password789"},
				},
				{
					cred:             credential.Credential{Password: "password123"},
					newAuthenticator: &mockRequestAuthenticator{authorizationHeader: "password123"},
				},
			},
			expectedCacheLen:   3,
			expectedKeyMatches: 5,
		},
		{
			name:                "If cache has item not of type RequestAuthenticator, delete it and call NewAuthenticator",
			initialItemsInCache: map[string]interface{}{"password123": "not a RequestAuthenticator"},
			cases: []testCase{
				{
					cred:                 credential.Credential{Password: "password123"},
					newAuthenticator:     &mockRequestAuthenticator{authorizationHeader: "password123"},
					callNewAuthenticator: true,
				},
			},
			expectedCacheLen:   1,
			expectedKeyMatches: 1,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			authenticators = nil
			once = sync.Once{}
			cache := getAuthenticatorCache()
			for key, value := range tt.initialItemsInCache {
				cache.Map.Store(key, value)
			}

			authenticatorFactory := mockAuthenticatorFactory{}
			authenticatorFactory.Test(t)
			defer authenticatorFactory.AssertExpectations(t)
			for _, c := range tt.cases {
				if c.callNewAuthenticator {
					authenticatorFactory.On("NewAuthenticator", c.cred.Password).
						Return(c.newAuthenticator, c.newAuthenticatorError).
						Once()
				}
			}

			s := &IBMVAScanner{
				authenticatorFactory: &authenticatorFactory,
			}
			for _, c := range tt.cases {
				gotAuthenticator, gotErr := s.getAuthenticator(c.cred)

				assert.Equal(t, c.newAuthenticator, gotAuthenticator)
				assert.Equal(t, c.expectedError, gotErr)
			}

			cacheSize, ketMatches := 0, 0
			cache.Map.Range(func(k, v interface{}) bool {
				for _, c := range tt.cases {
					// Loop round every test case to get check that the password is in the cache
					if k.(string) == c.cred.Password {
						ketMatches++
						assert.Equal(t, c.newAuthenticator, v)
					}
				}
				cacheSize++
				return true
			})

			assert.Equal(t, tt.expectedCacheLen, cacheSize)
			assert.Equal(t, tt.expectedKeyMatches, ketMatches)
		})
	}
}

func TestIBMVAScanner_createRequest(t *testing.T) {
	type authenticateMock struct {
		authorizationHeader string
		err                 error
	}
	type newAuthenticatorMock struct {
		authenticateMock *authenticateMock
		err              error
	}
	type wantRequest struct {
		authorizationHeader string
		account             string
	}
	tests := []struct {
		name             string
		accountHeader    string
		uri              string
		cred             credential.Credential
		newAuthenticator *newAuthenticatorMock
		wantRequest      *wantRequest
		wantErr          error
	}{
		{
			name: "If username is iamapikey, use iamauthenticator",
			uri:  "icr.io/wibble/thing",
			cred: credential.Credential{
				Username: "iamapikey",
				Password: "token123",
			},
			newAuthenticator: &newAuthenticatorMock{
				authenticateMock: &authenticateMock{
					authorizationHeader: "bearer token123",
				},
			},
			wantRequest: &wantRequest{
				authorizationHeader: "bearer token123",
			},
			wantErr: nil,
		},
		{
			name: "if getAuthenticator errors, use basic auth",
			uri:  "icr.io/wibble/thing",
			cred: credential.Credential{
				Username: "iamapikey",
				Password: "token123",
			},
			newAuthenticator: &newAuthenticatorMock{
				err: fmt.Errorf("uh oh"),
			},
			wantRequest: &wantRequest{
				authorizationHeader: "Basic " + base64.StdEncoding.EncodeToString([]byte("iamapikey:token123")),
			},
		},
		{
			name: "if Authenticate errors, use basic auth",
			uri:  "icr.io/wibble/thing",
			cred: credential.Credential{
				Username: "iamapikey",
				Password: "token123",
			},
			newAuthenticator: &newAuthenticatorMock{
				authenticateMock: &authenticateMock{
					err: fmt.Errorf("whoops"),
				},
			},
			wantRequest: &wantRequest{
				authorizationHeader: "Basic " + base64.StdEncoding.EncodeToString([]byte("iamapikey:token123")),
			},
		},
		{
			name: "If username is not iamapikey, use basic auth",
			uri:  "icr.io/wibble/thing",
			cred: credential.Credential{
				Username: "joebloggs",
				Password: "password123",
			},
			wantRequest: &wantRequest{
				authorizationHeader: "Basic " + base64.StdEncoding.EncodeToString([]byte("joebloggs:password123")),
			},
			wantErr: nil,
		},
		{
			name:          "Add account header if there is one",
			accountHeader: "jenniferbloggs",
			uri:           "icr.io/wibble/thing",
			cred: credential.Credential{
				Username: "joebloggs",
				Password: "password123",
			},
			wantRequest: &wantRequest{
				authorizationHeader: "Basic " + base64.StdEncoding.EncodeToString([]byte("joebloggs:password123")),
				account:             "jenniferbloggs",
			},
			wantErr: nil,
		},
		{
			name:          "Still add account header for iamapikey",
			accountHeader: "jenniferbloggs",
			uri:           "icr.io/wibble/thing",
			cred: credential.Credential{
				Username: "iamapikey",
				Password: "token123",
			},
			newAuthenticator: &newAuthenticatorMock{
				authenticateMock: &authenticateMock{
					authorizationHeader: "bearer token123",
				},
			},
			wantRequest: &wantRequest{
				authorizationHeader: "bearer token123",
				account:             "jenniferbloggs",
			},
			wantErr: nil,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			authenticators = nil
			once = sync.Once{}

			authenticatorFactory := mockAuthenticatorFactory{}
			authenticatorFactory.Test(t)
			defer authenticatorFactory.AssertExpectations(t)

			if tt.newAuthenticator != nil {
				authenticator := mockRequestAuthenticator{}
				authenticator.Test(t)
				defer authenticator.AssertExpectations(t)

				authenticate := tt.newAuthenticator.authenticateMock
				if authenticate != nil {
					authenticator.authorizationHeader = authenticate.authorizationHeader
					authenticator.
						On("Authenticate", mock.Anything).
						Return(authenticate.err).
						Once().
						Run(func(args mock.Arguments) {
							inrequest := args[0].(*http.Request)
							gotAccount := inrequest.Header.Get("Account")
							assert.Equal(t, tt.accountHeader, gotAccount)
						})
				}

				authenticatorFactory.
					On("NewAuthenticator", tt.cred.Password).
					Return(&authenticator, tt.newAuthenticator.err).Once()
			}

			c := &IBMVAScanner{
				AccountHeader:        tt.accountHeader,
				authenticatorFactory: &authenticatorFactory,
			}

			gotRequest, gotErr := c.createRequest(tt.cred, tt.uri)

			if tt.wantRequest != nil {
				assert.Equal(t, "GET", gotRequest.Method)
				assert.Equal(t, tt.uri, gotRequest.URL.Path)
				assert.Equal(t, tt.wantRequest.authorizationHeader, gotRequest.Header.Get("Authorization"))
				assert.Equal(t, tt.wantRequest.account, gotRequest.Header.Get("Account"))
			} else {
				assert.Nil(t, gotRequest)
			}
			assert.Equal(t, tt.wantErr, gotErr)
		})
	}
}
